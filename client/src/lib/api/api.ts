/* tslint:disable */
/* eslint-disable */
/**
 * Open Farms Inventory Service
 * Agriculture inventory management service.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface CreateImplementDto
 */
export interface CreateImplementDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateImplementDto
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof CreateImplementDto
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof CreateImplementDto
	 */
	locationId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CreateImplementDto
	 */
	tagName?: string;
}
/**
 *
 * @export
 * @interface CreateLocationDto
 */
export interface CreateLocationDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateLocationDto
	 */
	name: string;
}
/**
 *
 * @export
 * @interface CreateTagDto
 */
export interface CreateTagDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateTagDto
	 */
	name: string;
}
/**
 *
 * @export
 * @interface CreateToolDto
 */
export interface CreateToolDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateToolDto
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof CreateToolDto
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof CreateToolDto
	 */
	locationId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CreateToolDto
	 */
	tagName?: string;
}
/**
 *
 * @export
 * @interface ImplementResponse
 */
export interface ImplementResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof ImplementResponse
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	locationId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	tagName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof ImplementResponse
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface LocationResponse
 */
export interface LocationResponse {
	/**
	 *
	 * @type {string}
	 * @memberof LocationResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof LocationResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof LocationResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof LocationResponse
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
	/**
	 *
	 * @type {string}
	 * @memberof TagResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof TagResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof TagResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof TagResponse
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface ToolResponse
 */
export interface ToolResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof ToolResponse
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	locationId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	tagName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolResponse
	 */
	updatedAt: string;
}
/**
 *
 * @export
 * @interface UpdateImplementDto
 */
export interface UpdateImplementDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateImplementDto
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof UpdateImplementDto
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof UpdateImplementDto
	 */
	locationId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UpdateImplementDto
	 */
	tagName?: string;
}
/**
 *
 * @export
 * @interface UpdateLocationDto
 */
export interface UpdateLocationDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateLocationDto
	 */
	name: string;
}
/**
 *
 * @export
 * @interface UpdateTagDto
 */
export interface UpdateTagDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateTagDto
	 */
	name: string;
}
/**
 *
 * @export
 * @interface UpdateToolDto
 */
export interface UpdateToolDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateToolDto
	 */
	name: string;
	/**
	 *
	 * @type {object}
	 * @memberof UpdateToolDto
	 */
	condition?: object;
	/**
	 *
	 * @type {string}
	 * @memberof UpdateToolDto
	 */
	tagName?: string;
}

/**
 * ImplementsApi - axios parameter creator
 * @export
 */
export const ImplementsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {CreateImplementDto} createImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerCreate: async (
			createImplementDto: CreateImplementDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createImplementDto' is not null or undefined
			assertParamExists('implementsControllerCreate', 'createImplementDto', createImplementDto);
			const localVarPath = `/api/implements`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(createImplementDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('implementsControllerDelete', 'id', id);
			const localVarPath = `/api/implements/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerFindById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('implementsControllerFindById', 'id', id);
			const localVarPath = `/api/implements/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerList: async (
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/api/implements`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (name !== undefined) {
				localVarQueryParameter['name'] = name;
			}

			if (orderBy !== undefined) {
				localVarQueryParameter['orderBy'] = orderBy;
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateImplementDto} updateImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerUpdate: async (
			id: string,
			updateImplementDto: UpdateImplementDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('implementsControllerUpdate', 'id', id);
			// verify required parameter 'updateImplementDto' is not null or undefined
			assertParamExists('implementsControllerUpdate', 'updateImplementDto', updateImplementDto);
			const localVarPath = `/api/implements/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(updateImplementDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * ImplementsApi - functional programming interface
 * @export
 */
export const ImplementsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ImplementsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {CreateImplementDto} createImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async implementsControllerCreate(
			createImplementDto: CreateImplementDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImplementResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.implementsControllerCreate(createImplementDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async implementsControllerDelete(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImplementResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.implementsControllerDelete(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async implementsControllerFindById(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImplementResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.implementsControllerFindById(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async implementsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImplementResponse>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.implementsControllerList(name, orderBy, sort, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateImplementDto} updateImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async implementsControllerUpdate(
			id: string,
			updateImplementDto: UpdateImplementDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImplementResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.implementsControllerUpdate(
				id,
				updateImplementDto,
				options
			);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		}
	};
};

/**
 * ImplementsApi - factory interface
 * @export
 */
export const ImplementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = ImplementsApiFp(configuration);
	return {
		/**
		 *
		 * @param {CreateImplementDto} createImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerCreate(createImplementDto: CreateImplementDto, options?: any): AxiosPromise<ImplementResponse> {
			return localVarFp
				.implementsControllerCreate(createImplementDto, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerDelete(id: string, options?: any): AxiosPromise<ImplementResponse> {
			return localVarFp.implementsControllerDelete(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerFindById(id: string, options?: any): AxiosPromise<ImplementResponse> {
			return localVarFp.implementsControllerFindById(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options?: any
		): AxiosPromise<Array<ImplementResponse>> {
			return localVarFp
				.implementsControllerList(name, orderBy, sort, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateImplementDto} updateImplementDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		implementsControllerUpdate(
			id: string,
			updateImplementDto: UpdateImplementDto,
			options?: any
		): AxiosPromise<ImplementResponse> {
			return localVarFp
				.implementsControllerUpdate(id, updateImplementDto, options)
				.then((request) => request(axios, basePath));
		}
	};
};

/**
 * Request parameters for implementsControllerCreate operation in ImplementsApi.
 * @export
 * @interface ImplementsApiImplementsControllerCreateRequest
 */
export interface ImplementsApiImplementsControllerCreateRequest {
	/**
	 *
	 * @type {CreateImplementDto}
	 * @memberof ImplementsApiImplementsControllerCreate
	 */
	readonly createImplementDto: CreateImplementDto;
}

/**
 * Request parameters for implementsControllerDelete operation in ImplementsApi.
 * @export
 * @interface ImplementsApiImplementsControllerDeleteRequest
 */
export interface ImplementsApiImplementsControllerDeleteRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ImplementsApiImplementsControllerDelete
	 */
	readonly id: string;
}

/**
 * Request parameters for implementsControllerFindById operation in ImplementsApi.
 * @export
 * @interface ImplementsApiImplementsControllerFindByIdRequest
 */
export interface ImplementsApiImplementsControllerFindByIdRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ImplementsApiImplementsControllerFindById
	 */
	readonly id: string;
}

/**
 * Request parameters for implementsControllerList operation in ImplementsApi.
 * @export
 * @interface ImplementsApiImplementsControllerListRequest
 */
export interface ImplementsApiImplementsControllerListRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ImplementsApiImplementsControllerList
	 */
	readonly name?: string;

	/**
	 *
	 * @type {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'}
	 * @memberof ImplementsApiImplementsControllerList
	 */
	readonly orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId';

	/**
	 *
	 * @type {'asc' | 'desc'}
	 * @memberof ImplementsApiImplementsControllerList
	 */
	readonly sort?: 'asc' | 'desc';
}

/**
 * Request parameters for implementsControllerUpdate operation in ImplementsApi.
 * @export
 * @interface ImplementsApiImplementsControllerUpdateRequest
 */
export interface ImplementsApiImplementsControllerUpdateRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ImplementsApiImplementsControllerUpdate
	 */
	readonly id: string;

	/**
	 *
	 * @type {UpdateImplementDto}
	 * @memberof ImplementsApiImplementsControllerUpdate
	 */
	readonly updateImplementDto: UpdateImplementDto;
}

/**
 * ImplementsApi - object-oriented interface
 * @export
 * @class ImplementsApi
 * @extends {BaseAPI}
 */
export class ImplementsApi extends BaseAPI {
	/**
	 *
	 * @param {ImplementsApiImplementsControllerCreateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImplementsApi
	 */
	public implementsControllerCreate(
		requestParameters: ImplementsApiImplementsControllerCreateRequest,
		options?: AxiosRequestConfig
	) {
		return ImplementsApiFp(this.configuration)
			.implementsControllerCreate(requestParameters.createImplementDto, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ImplementsApiImplementsControllerDeleteRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImplementsApi
	 */
	public implementsControllerDelete(
		requestParameters: ImplementsApiImplementsControllerDeleteRequest,
		options?: AxiosRequestConfig
	) {
		return ImplementsApiFp(this.configuration)
			.implementsControllerDelete(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ImplementsApiImplementsControllerFindByIdRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImplementsApi
	 */
	public implementsControllerFindById(
		requestParameters: ImplementsApiImplementsControllerFindByIdRequest,
		options?: AxiosRequestConfig
	) {
		return ImplementsApiFp(this.configuration)
			.implementsControllerFindById(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ImplementsApiImplementsControllerListRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImplementsApi
	 */
	public implementsControllerList(
		requestParameters: ImplementsApiImplementsControllerListRequest = {},
		options?: AxiosRequestConfig
	) {
		return ImplementsApiFp(this.configuration)
			.implementsControllerList(requestParameters.name, requestParameters.orderBy, requestParameters.sort, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ImplementsApiImplementsControllerUpdateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImplementsApi
	 */
	public implementsControllerUpdate(
		requestParameters: ImplementsApiImplementsControllerUpdateRequest,
		options?: AxiosRequestConfig
	) {
		return ImplementsApiFp(this.configuration)
			.implementsControllerUpdate(requestParameters.id, requestParameters.updateImplementDto, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {CreateLocationDto} createLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerCreate: async (
			createLocationDto: CreateLocationDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createLocationDto' is not null or undefined
			assertParamExists('locationsControllerCreate', 'createLocationDto', createLocationDto);
			const localVarPath = `/api/locations`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(createLocationDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('locationsControllerDelete', 'id', id);
			const localVarPath = `/api/locations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerFindByName: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('locationsControllerFindByName', 'id', id);
			const localVarPath = `/api/locations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerList: async (
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt',
			sort?: 'asc' | 'desc',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/api/locations`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (name !== undefined) {
				localVarQueryParameter['name'] = name;
			}

			if (orderBy !== undefined) {
				localVarQueryParameter['orderBy'] = orderBy;
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateLocationDto} updateLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerUpdate: async (
			id: string,
			updateLocationDto: UpdateLocationDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('locationsControllerUpdate', 'id', id);
			// verify required parameter 'updateLocationDto' is not null or undefined
			assertParamExists('locationsControllerUpdate', 'updateLocationDto', updateLocationDto);
			const localVarPath = `/api/locations/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(updateLocationDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {CreateLocationDto} createLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsControllerCreate(
			createLocationDto: CreateLocationDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerCreate(createLocationDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsControllerDelete(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerDelete(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsControllerFindByName(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerFindByName(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt',
			sort?: 'asc' | 'desc',
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocationResponse>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerList(name, orderBy, sort, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateLocationDto} updateLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsControllerUpdate(
			id: string,
			updateLocationDto: UpdateLocationDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.locationsControllerUpdate(
				id,
				updateLocationDto,
				options
			);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		}
	};
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = LocationsApiFp(configuration);
	return {
		/**
		 *
		 * @param {CreateLocationDto} createLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerCreate(createLocationDto: CreateLocationDto, options?: any): AxiosPromise<LocationResponse> {
			return localVarFp
				.locationsControllerCreate(createLocationDto, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerDelete(id: string, options?: any): AxiosPromise<LocationResponse> {
			return localVarFp.locationsControllerDelete(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerFindByName(id: string, options?: any): AxiosPromise<LocationResponse> {
			return localVarFp.locationsControllerFindByName(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt',
			sort?: 'asc' | 'desc',
			options?: any
		): AxiosPromise<Array<LocationResponse>> {
			return localVarFp
				.locationsControllerList(name, orderBy, sort, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateLocationDto} updateLocationDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsControllerUpdate(
			id: string,
			updateLocationDto: UpdateLocationDto,
			options?: any
		): AxiosPromise<LocationResponse> {
			return localVarFp
				.locationsControllerUpdate(id, updateLocationDto, options)
				.then((request) => request(axios, basePath));
		}
	};
};

/**
 * Request parameters for locationsControllerCreate operation in LocationsApi.
 * @export
 * @interface LocationsApiLocationsControllerCreateRequest
 */
export interface LocationsApiLocationsControllerCreateRequest {
	/**
	 *
	 * @type {CreateLocationDto}
	 * @memberof LocationsApiLocationsControllerCreate
	 */
	readonly createLocationDto: CreateLocationDto;
}

/**
 * Request parameters for locationsControllerDelete operation in LocationsApi.
 * @export
 * @interface LocationsApiLocationsControllerDeleteRequest
 */
export interface LocationsApiLocationsControllerDeleteRequest {
	/**
	 *
	 * @type {string}
	 * @memberof LocationsApiLocationsControllerDelete
	 */
	readonly id: string;
}

/**
 * Request parameters for locationsControllerFindByName operation in LocationsApi.
 * @export
 * @interface LocationsApiLocationsControllerFindByNameRequest
 */
export interface LocationsApiLocationsControllerFindByNameRequest {
	/**
	 *
	 * @type {string}
	 * @memberof LocationsApiLocationsControllerFindByName
	 */
	readonly id: string;
}

/**
 * Request parameters for locationsControllerList operation in LocationsApi.
 * @export
 * @interface LocationsApiLocationsControllerListRequest
 */
export interface LocationsApiLocationsControllerListRequest {
	/**
	 *
	 * @type {string}
	 * @memberof LocationsApiLocationsControllerList
	 */
	readonly name?: string;

	/**
	 *
	 * @type {'id' | 'name' | 'createdAt' | 'updatedAt'}
	 * @memberof LocationsApiLocationsControllerList
	 */
	readonly orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt';

	/**
	 *
	 * @type {'asc' | 'desc'}
	 * @memberof LocationsApiLocationsControllerList
	 */
	readonly sort?: 'asc' | 'desc';
}

/**
 * Request parameters for locationsControllerUpdate operation in LocationsApi.
 * @export
 * @interface LocationsApiLocationsControllerUpdateRequest
 */
export interface LocationsApiLocationsControllerUpdateRequest {
	/**
	 *
	 * @type {string}
	 * @memberof LocationsApiLocationsControllerUpdate
	 */
	readonly id: string;

	/**
	 *
	 * @type {UpdateLocationDto}
	 * @memberof LocationsApiLocationsControllerUpdate
	 */
	readonly updateLocationDto: UpdateLocationDto;
}

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
	/**
	 *
	 * @param {LocationsApiLocationsControllerCreateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsControllerCreate(
		requestParameters: LocationsApiLocationsControllerCreateRequest,
		options?: AxiosRequestConfig
	) {
		return LocationsApiFp(this.configuration)
			.locationsControllerCreate(requestParameters.createLocationDto, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {LocationsApiLocationsControllerDeleteRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsControllerDelete(
		requestParameters: LocationsApiLocationsControllerDeleteRequest,
		options?: AxiosRequestConfig
	) {
		return LocationsApiFp(this.configuration)
			.locationsControllerDelete(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {LocationsApiLocationsControllerFindByNameRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsControllerFindByName(
		requestParameters: LocationsApiLocationsControllerFindByNameRequest,
		options?: AxiosRequestConfig
	) {
		return LocationsApiFp(this.configuration)
			.locationsControllerFindByName(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {LocationsApiLocationsControllerListRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsControllerList(
		requestParameters: LocationsApiLocationsControllerListRequest = {},
		options?: AxiosRequestConfig
	) {
		return LocationsApiFp(this.configuration)
			.locationsControllerList(requestParameters.name, requestParameters.orderBy, requestParameters.sort, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {LocationsApiLocationsControllerUpdateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsControllerUpdate(
		requestParameters: LocationsApiLocationsControllerUpdateRequest,
		options?: AxiosRequestConfig
	) {
		return LocationsApiFp(this.configuration)
			.locationsControllerUpdate(requestParameters.id, requestParameters.updateLocationDto, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {CreateTagDto} createTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerCreate: async (
			createTagDto: CreateTagDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createTagDto' is not null or undefined
			assertParamExists('tagsControllerCreate', 'createTagDto', createTagDto);
			const localVarPath = `/api/tags`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(createTagDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerDelete: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'name' is not null or undefined
			assertParamExists('tagsControllerDelete', 'name', name);
			const localVarPath = `/api/tags/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerFindById: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'name' is not null or undefined
			assertParamExists('tagsControllerFindById', 'name', name);
			const localVarPath = `/api/tags/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerList: async (
			name?: string,
			sort?: 'asc' | 'desc',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/api/tags`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (name !== undefined) {
				localVarQueryParameter['name'] = name;
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} name
		 * @param {UpdateTagDto} updateTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerUpdate: async (
			name: string,
			updateTagDto: UpdateTagDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'name' is not null or undefined
			assertParamExists('tagsControllerUpdate', 'name', name);
			// verify required parameter 'updateTagDto' is not null or undefined
			assertParamExists('tagsControllerUpdate', 'updateTagDto', updateTagDto);
			const localVarPath = `/api/tags/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(updateTagDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {CreateTagDto} createTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tagsControllerCreate(
			createTagDto: CreateTagDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerCreate(createTagDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tagsControllerDelete(
			name: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerDelete(name, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tagsControllerFindById(
			name: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerFindById(name, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tagsControllerList(
			name?: string,
			sort?: 'asc' | 'desc',
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagResponse>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerList(name, sort, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} name
		 * @param {UpdateTagDto} updateTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async tagsControllerUpdate(
			name: string,
			updateTagDto: UpdateTagDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.tagsControllerUpdate(name, updateTagDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		}
	};
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = TagsApiFp(configuration);
	return {
		/**
		 *
		 * @param {CreateTagDto} createTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerCreate(createTagDto: CreateTagDto, options?: any): AxiosPromise<TagResponse> {
			return localVarFp.tagsControllerCreate(createTagDto, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerDelete(name: string, options?: any): AxiosPromise<TagResponse> {
			return localVarFp.tagsControllerDelete(name, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerFindById(name: string, options?: any): AxiosPromise<TagResponse> {
			return localVarFp.tagsControllerFindById(name, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerList(name?: string, sort?: 'asc' | 'desc', options?: any): AxiosPromise<Array<TagResponse>> {
			return localVarFp.tagsControllerList(name, sort, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} name
		 * @param {UpdateTagDto} updateTagDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		tagsControllerUpdate(name: string, updateTagDto: UpdateTagDto, options?: any): AxiosPromise<TagResponse> {
			return localVarFp.tagsControllerUpdate(name, updateTagDto, options).then((request) => request(axios, basePath));
		}
	};
};

/**
 * Request parameters for tagsControllerCreate operation in TagsApi.
 * @export
 * @interface TagsApiTagsControllerCreateRequest
 */
export interface TagsApiTagsControllerCreateRequest {
	/**
	 *
	 * @type {CreateTagDto}
	 * @memberof TagsApiTagsControllerCreate
	 */
	readonly createTagDto: CreateTagDto;
}

/**
 * Request parameters for tagsControllerDelete operation in TagsApi.
 * @export
 * @interface TagsApiTagsControllerDeleteRequest
 */
export interface TagsApiTagsControllerDeleteRequest {
	/**
	 *
	 * @type {string}
	 * @memberof TagsApiTagsControllerDelete
	 */
	readonly name: string;
}

/**
 * Request parameters for tagsControllerFindById operation in TagsApi.
 * @export
 * @interface TagsApiTagsControllerFindByIdRequest
 */
export interface TagsApiTagsControllerFindByIdRequest {
	/**
	 *
	 * @type {string}
	 * @memberof TagsApiTagsControllerFindById
	 */
	readonly name: string;
}

/**
 * Request parameters for tagsControllerList operation in TagsApi.
 * @export
 * @interface TagsApiTagsControllerListRequest
 */
export interface TagsApiTagsControllerListRequest {
	/**
	 *
	 * @type {string}
	 * @memberof TagsApiTagsControllerList
	 */
	readonly name?: string;

	/**
	 *
	 * @type {'asc' | 'desc'}
	 * @memberof TagsApiTagsControllerList
	 */
	readonly sort?: 'asc' | 'desc';
}

/**
 * Request parameters for tagsControllerUpdate operation in TagsApi.
 * @export
 * @interface TagsApiTagsControllerUpdateRequest
 */
export interface TagsApiTagsControllerUpdateRequest {
	/**
	 *
	 * @type {string}
	 * @memberof TagsApiTagsControllerUpdate
	 */
	readonly name: string;

	/**
	 *
	 * @type {UpdateTagDto}
	 * @memberof TagsApiTagsControllerUpdate
	 */
	readonly updateTagDto: UpdateTagDto;
}

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
	/**
	 *
	 * @param {TagsApiTagsControllerCreateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TagsApi
	 */
	public tagsControllerCreate(requestParameters: TagsApiTagsControllerCreateRequest, options?: AxiosRequestConfig) {
		return TagsApiFp(this.configuration)
			.tagsControllerCreate(requestParameters.createTagDto, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {TagsApiTagsControllerDeleteRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TagsApi
	 */
	public tagsControllerDelete(requestParameters: TagsApiTagsControllerDeleteRequest, options?: AxiosRequestConfig) {
		return TagsApiFp(this.configuration)
			.tagsControllerDelete(requestParameters.name, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {TagsApiTagsControllerFindByIdRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TagsApi
	 */
	public tagsControllerFindById(requestParameters: TagsApiTagsControllerFindByIdRequest, options?: AxiosRequestConfig) {
		return TagsApiFp(this.configuration)
			.tagsControllerFindById(requestParameters.name, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {TagsApiTagsControllerListRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TagsApi
	 */
	public tagsControllerList(requestParameters: TagsApiTagsControllerListRequest = {}, options?: AxiosRequestConfig) {
		return TagsApiFp(this.configuration)
			.tagsControllerList(requestParameters.name, requestParameters.sort, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {TagsApiTagsControllerUpdateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TagsApi
	 */
	public tagsControllerUpdate(requestParameters: TagsApiTagsControllerUpdateRequest, options?: AxiosRequestConfig) {
		return TagsApiFp(this.configuration)
			.tagsControllerUpdate(requestParameters.name, requestParameters.updateTagDto, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ToolsApi - axios parameter creator
 * @export
 */
export const ToolsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {CreateToolDto} createToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerCreate: async (
			createToolDto: CreateToolDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createToolDto' is not null or undefined
			assertParamExists('toolsControllerCreate', 'createToolDto', createToolDto);
			const localVarPath = `/api/tools`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(createToolDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('toolsControllerDelete', 'id', id);
			const localVarPath = `/api/tools/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerFindById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('toolsControllerFindById', 'id', id);
			const localVarPath = `/api/tools/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerList: async (
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/api/tools`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (name !== undefined) {
				localVarQueryParameter['name'] = name;
			}

			if (orderBy !== undefined) {
				localVarQueryParameter['orderBy'] = orderBy;
			}

			if (sort !== undefined) {
				localVarQueryParameter['sort'] = sort;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateToolDto} updateToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerUpdate: async (
			id: string,
			updateToolDto: UpdateToolDto,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('toolsControllerUpdate', 'id', id);
			// verify required parameter 'updateToolDto' is not null or undefined
			assertParamExists('toolsControllerUpdate', 'updateToolDto', updateToolDto);
			const localVarPath = `/api/tools/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
			localVarRequestOptions.data = serializeDataIfNeeded(updateToolDto, localVarRequestOptions, configuration);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * ToolsApi - functional programming interface
 * @export
 */
export const ToolsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ToolsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {CreateToolDto} createToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolsControllerCreate(
			createToolDto: CreateToolDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.toolsControllerCreate(createToolDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolsControllerDelete(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.toolsControllerDelete(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolsControllerFindById(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.toolsControllerFindById(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.toolsControllerList(name, orderBy, sort, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateToolDto} updateToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolsControllerUpdate(
			id: string,
			updateToolDto: UpdateToolDto,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolResponse>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.toolsControllerUpdate(id, updateToolDto, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		}
	};
};

/**
 * ToolsApi - factory interface
 * @export
 */
export const ToolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = ToolsApiFp(configuration);
	return {
		/**
		 *
		 * @param {CreateToolDto} createToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerCreate(createToolDto: CreateToolDto, options?: any): AxiosPromise<ToolResponse> {
			return localVarFp.toolsControllerCreate(createToolDto, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerDelete(id: string, options?: any): AxiosPromise<ToolResponse> {
			return localVarFp.toolsControllerDelete(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerFindById(id: string, options?: any): AxiosPromise<ToolResponse> {
			return localVarFp.toolsControllerFindById(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'} [orderBy]
		 * @param {'asc' | 'desc'} [sort]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerList(
			name?: string,
			orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId',
			sort?: 'asc' | 'desc',
			options?: any
		): AxiosPromise<void> {
			return localVarFp.toolsControllerList(name, orderBy, sort, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateToolDto} updateToolDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolsControllerUpdate(id: string, updateToolDto: UpdateToolDto, options?: any): AxiosPromise<ToolResponse> {
			return localVarFp.toolsControllerUpdate(id, updateToolDto, options).then((request) => request(axios, basePath));
		}
	};
};

/**
 * Request parameters for toolsControllerCreate operation in ToolsApi.
 * @export
 * @interface ToolsApiToolsControllerCreateRequest
 */
export interface ToolsApiToolsControllerCreateRequest {
	/**
	 *
	 * @type {CreateToolDto}
	 * @memberof ToolsApiToolsControllerCreate
	 */
	readonly createToolDto: CreateToolDto;
}

/**
 * Request parameters for toolsControllerDelete operation in ToolsApi.
 * @export
 * @interface ToolsApiToolsControllerDeleteRequest
 */
export interface ToolsApiToolsControllerDeleteRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ToolsApiToolsControllerDelete
	 */
	readonly id: string;
}

/**
 * Request parameters for toolsControllerFindById operation in ToolsApi.
 * @export
 * @interface ToolsApiToolsControllerFindByIdRequest
 */
export interface ToolsApiToolsControllerFindByIdRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ToolsApiToolsControllerFindById
	 */
	readonly id: string;
}

/**
 * Request parameters for toolsControllerList operation in ToolsApi.
 * @export
 * @interface ToolsApiToolsControllerListRequest
 */
export interface ToolsApiToolsControllerListRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ToolsApiToolsControllerList
	 */
	readonly name?: string;

	/**
	 *
	 * @type {'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId'}
	 * @memberof ToolsApiToolsControllerList
	 */
	readonly orderBy?: 'id' | 'name' | 'createdAt' | 'updatedAt' | 'condition' | 'tagName' | 'locationId';

	/**
	 *
	 * @type {'asc' | 'desc'}
	 * @memberof ToolsApiToolsControllerList
	 */
	readonly sort?: 'asc' | 'desc';
}

/**
 * Request parameters for toolsControllerUpdate operation in ToolsApi.
 * @export
 * @interface ToolsApiToolsControllerUpdateRequest
 */
export interface ToolsApiToolsControllerUpdateRequest {
	/**
	 *
	 * @type {string}
	 * @memberof ToolsApiToolsControllerUpdate
	 */
	readonly id: string;

	/**
	 *
	 * @type {UpdateToolDto}
	 * @memberof ToolsApiToolsControllerUpdate
	 */
	readonly updateToolDto: UpdateToolDto;
}

/**
 * ToolsApi - object-oriented interface
 * @export
 * @class ToolsApi
 * @extends {BaseAPI}
 */
export class ToolsApi extends BaseAPI {
	/**
	 *
	 * @param {ToolsApiToolsControllerCreateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolsApi
	 */
	public toolsControllerCreate(requestParameters: ToolsApiToolsControllerCreateRequest, options?: AxiosRequestConfig) {
		return ToolsApiFp(this.configuration)
			.toolsControllerCreate(requestParameters.createToolDto, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ToolsApiToolsControllerDeleteRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolsApi
	 */
	public toolsControllerDelete(requestParameters: ToolsApiToolsControllerDeleteRequest, options?: AxiosRequestConfig) {
		return ToolsApiFp(this.configuration)
			.toolsControllerDelete(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ToolsApiToolsControllerFindByIdRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolsApi
	 */
	public toolsControllerFindById(
		requestParameters: ToolsApiToolsControllerFindByIdRequest,
		options?: AxiosRequestConfig
	) {
		return ToolsApiFp(this.configuration)
			.toolsControllerFindById(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ToolsApiToolsControllerListRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolsApi
	 */
	public toolsControllerList(requestParameters: ToolsApiToolsControllerListRequest = {}, options?: AxiosRequestConfig) {
		return ToolsApiFp(this.configuration)
			.toolsControllerList(requestParameters.name, requestParameters.orderBy, requestParameters.sort, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ToolsApiToolsControllerUpdateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolsApi
	 */
	public toolsControllerUpdate(requestParameters: ToolsApiToolsControllerUpdateRequest, options?: AxiosRequestConfig) {
		return ToolsApiFp(this.configuration)
			.toolsControllerUpdate(requestParameters.id, requestParameters.updateToolDto, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/vehicles`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('vehiclesControllerDelete', 'id', id);
			const localVarPath = `/api/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerFindById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('vehiclesControllerFindById', 'id', id);
			const localVarPath = `/api/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerList: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'name' is not null or undefined
			assertParamExists('vehiclesControllerList', 'name', name);
			const localVarPath = `/api/vehicles`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (name !== undefined) {
				localVarQueryParameter['name'] = name;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerUpdate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('vehiclesControllerUpdate', 'id', id);
			const localVarPath = `/api/vehicles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async vehiclesControllerCreate(
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerCreate(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async vehiclesControllerDelete(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerDelete(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async vehiclesControllerFindById(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerFindById(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async vehiclesControllerList(
			name: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerList(name, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async vehiclesControllerUpdate(
			id: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.vehiclesControllerUpdate(id, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		}
	};
};

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = VehiclesApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerCreate(options?: any): AxiosPromise<void> {
			return localVarFp.vehiclesControllerCreate(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerDelete(id: string, options?: any): AxiosPromise<void> {
			return localVarFp.vehiclesControllerDelete(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerFindById(id: string, options?: any): AxiosPromise<void> {
			return localVarFp.vehiclesControllerFindById(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} name
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerList(name: string, options?: any): AxiosPromise<void> {
			return localVarFp.vehiclesControllerList(name, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		vehiclesControllerUpdate(id: string, options?: any): AxiosPromise<void> {
			return localVarFp.vehiclesControllerUpdate(id, options).then((request) => request(axios, basePath));
		}
	};
};

/**
 * Request parameters for vehiclesControllerDelete operation in VehiclesApi.
 * @export
 * @interface VehiclesApiVehiclesControllerDeleteRequest
 */
export interface VehiclesApiVehiclesControllerDeleteRequest {
	/**
	 *
	 * @type {string}
	 * @memberof VehiclesApiVehiclesControllerDelete
	 */
	readonly id: string;
}

/**
 * Request parameters for vehiclesControllerFindById operation in VehiclesApi.
 * @export
 * @interface VehiclesApiVehiclesControllerFindByIdRequest
 */
export interface VehiclesApiVehiclesControllerFindByIdRequest {
	/**
	 *
	 * @type {string}
	 * @memberof VehiclesApiVehiclesControllerFindById
	 */
	readonly id: string;
}

/**
 * Request parameters for vehiclesControllerList operation in VehiclesApi.
 * @export
 * @interface VehiclesApiVehiclesControllerListRequest
 */
export interface VehiclesApiVehiclesControllerListRequest {
	/**
	 *
	 * @type {string}
	 * @memberof VehiclesApiVehiclesControllerList
	 */
	readonly name: string;
}

/**
 * Request parameters for vehiclesControllerUpdate operation in VehiclesApi.
 * @export
 * @interface VehiclesApiVehiclesControllerUpdateRequest
 */
export interface VehiclesApiVehiclesControllerUpdateRequest {
	/**
	 *
	 * @type {string}
	 * @memberof VehiclesApiVehiclesControllerUpdate
	 */
	readonly id: string;
}

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VehiclesApi
	 */
	public vehiclesControllerCreate(options?: AxiosRequestConfig) {
		return VehiclesApiFp(this.configuration)
			.vehiclesControllerCreate(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {VehiclesApiVehiclesControllerDeleteRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VehiclesApi
	 */
	public vehiclesControllerDelete(
		requestParameters: VehiclesApiVehiclesControllerDeleteRequest,
		options?: AxiosRequestConfig
	) {
		return VehiclesApiFp(this.configuration)
			.vehiclesControllerDelete(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {VehiclesApiVehiclesControllerFindByIdRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VehiclesApi
	 */
	public vehiclesControllerFindById(
		requestParameters: VehiclesApiVehiclesControllerFindByIdRequest,
		options?: AxiosRequestConfig
	) {
		return VehiclesApiFp(this.configuration)
			.vehiclesControllerFindById(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {VehiclesApiVehiclesControllerListRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VehiclesApi
	 */
	public vehiclesControllerList(
		requestParameters: VehiclesApiVehiclesControllerListRequest,
		options?: AxiosRequestConfig
	) {
		return VehiclesApiFp(this.configuration)
			.vehiclesControllerList(requestParameters.name, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {VehiclesApiVehiclesControllerUpdateRequest} requestParameters Request parameters.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VehiclesApi
	 */
	public vehiclesControllerUpdate(
		requestParameters: VehiclesApiVehiclesControllerUpdateRequest,
		options?: AxiosRequestConfig
	) {
		return VehiclesApiFp(this.configuration)
			.vehiclesControllerUpdate(requestParameters.id, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
